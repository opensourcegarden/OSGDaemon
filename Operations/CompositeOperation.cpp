#include "CompositeOperation.h"

namespace Operations {




Json::Value CompositeOperation::execute()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-7cb871eb:1499b9437b8:-8000:0000000000000A71 begin
{
		Json::Value composite_root(Json::objectValue);
		// std::vector<std::vector<std::string> > statuses;
		Json::Value execution_statuses(Json::arrayValue);

		// std::vector<std::string> composite_status;
		composite_root["composite"] = true;
		
		// composite_status.push_back("starting execution of composite");

		// statuses.push_back(composite_status);

		std::vector<AbstractOperation*>::iterator it;
		// Json::Value x(Json::nullValue);
		for(it = child_operations.begin(); it != child_operations.end(); ++it) {
			Json::Value execution(Json::objectValue);
			execution = (*it)->execute();
			Json::StyledWriter writer;
			std::string exe_string(writer.write(execution));

			execution_statuses.append(execution);
			if( execution.isMember("runOnce"))	 {
				// std::cout << execution["runOnce"] << std::endl;

			}
		}
		composite_root["execution_statuses"] = execution_statuses;
		return composite_root;
		// composite_status.push_back("finished execution of composite");


}
// section 127-0-1-1-7cb871eb:1499b9437b8:-8000:0000000000000A71 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Json::Value CompositeOperation::getExecutionTree() {
	Json::Value object(Json::objectValue);
	object["composite"] = true;
	
	Json::Value operations(Json::arrayValue);
	std::vector<AbstractOperation*>::iterator it;
	for ( it = child_operations.begin(); it != child_operations.end(); ++it ) {
		Json::Value child_object = (*it)->getExecutionTree();
		operations.append(child_object);
	}
	object["operations"] = operations;
	return object;
}

AbstractOperation* CompositeOperation::addChild(AbstractOperation* child) {
	child_operations.push_back(child);
	return child;
}

AbstractOperation* CompositeOperation::removeChild(AbstractOperation* operation) {
	std::vector<AbstractOperation*>::iterator it;

	for(it = child_operations.begin(); it != child_operations.end(); ++it) {
		if(operation == *it) {
			AbstractOperation* op = *it;
			// std::remove(child_operations.begin(), child_operations.end(), operation);
			return op;
		}
	}
}

int CompositeOperation::getNumChildren() {
	return child_operations.size();
}

} /* End of namespace Operations */


